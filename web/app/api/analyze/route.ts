"use server";

import { NextResponse } from "next/server";
import path from "path";
import { spawn } from "child_process";
import fs from "fs/promises";
import fsSync from "fs";
import { mkdirSync, existsSync } from "fs";
import { setProcess, clearProcess, getWasStoppedByUser } from "./processManager";

/**
 * üßπ Utility function to safely delete a directory and its contents.
 * This is used after each job to keep the upload folder clean.
 */
async function cleanupDir(dirPath: string) {
  try {
    if (existsSync(dirPath)) {
      await fs.rm(dirPath, { recursive: true, force: true });
    }
  } catch (err) {
    console.warn(`‚ö†Ô∏è Cleanup failed for ${dirPath}:`, err);
  }
}

/**
 * üìÑ Recursively search for the JSON report file generated by Python.
 * This handles nested directories automatically.
 */
async function findReportFile(dir: string): Promise<string | null> {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);

    // Match any JSON file that starts with "offsets_" (Python output pattern)
    if (entry.isFile() && entry.name.startsWith("offsets_") && entry.name.endsWith(".json")) {
      return fullPath;
    }

    // Recursively search subdirectories
    if (entry.isDirectory()) {
      const found = await findReportFile(fullPath);
      if (found) return found;
    }
  }
  return null;
}

/**
 * üì® API POST Handler
 * - Receives reference + candidate audio files.
 * - Saves them to backend upload folder.
 * - Spawns the Python process to run the matching pipeline.
 * - Waits for process to finish, parses the report, and returns structured JSON.
 */
export async function POST(req: Request) {
  const controller = new AbortController();
  // (optional) Timeout can be added here if needed
  // const timeoutMs = 10 * 60 * 1000;
  // const timeout = setTimeout(() => controller.abort(), timeoutMs);

  try {
    // üßæ Parse form data
    const formData = await req.formData();
    const referenceFile = formData.get("reference") as File | null;
    const candidateFiles = formData.getAll("candidates") as File[];

    // Validate incoming files
    if (!referenceFile || candidateFiles.length === 0) {
      return NextResponse.json(
        { error: "Reference and candidate audio files are required." },
        { status: 400 }
      );
    }

    // üìÇ Define backend paths
    const backendRoot = path.join(process.cwd(), "../backend");
    const referenceDir = path.join(backendRoot, "uploads", "reference");
    const candidatesDir = path.join(backendRoot, "uploads", "candidates");
    const outputDir = path.join(backendRoot, "processed");

    // Ensure directories exist
    [referenceDir, candidatesDir, outputDir].forEach((dir) =>
      mkdirSync(dir, { recursive: true })
    );

    const liveLogs: string[] = [];

    /**
     * üì• Save reference audio file
     */
    const refPath = path.join(referenceDir, referenceFile.name);
    const refBuffer = Buffer.from(await referenceFile.arrayBuffer());
    await fs.writeFile(refPath, refBuffer);
    liveLogs.push(`‚úÖ Reference uploaded: ${referenceFile.name}`);
    console.log(`‚úÖ Reference uploaded: ${referenceFile.name}`);

    /**
     * üì• Save all candidate audio files
     */
    for (const file of candidateFiles) {
      const filePath = path.join(candidatesDir, file.name);
      const buffer = Buffer.from(await file.arrayBuffer());
      await fs.writeFile(filePath, buffer);
      liveLogs.push(`‚úÖ Candidate uploaded: ${file.name}`);
      console.log(`‚úÖ Candidate uploaded: ${file.name}`);
    }

    /**
     * üêç Run Python CLI script
     * - match.py processes audio files, aligns them, and generates a JSON report
     */
    const pythonScript = path.join(backendRoot, "match.py");
    const args = [
      pythonScript,
      "--audio-dir",
      candidatesDir,
      "--unified",
      refPath,
      "-o",
      outputDir,
      "--export-audio",   // force python to generate aligned audio files
      "--format", "wav",
    ];

    console.log("‚ñ∂Ô∏è Running Python CLI:", ["python", ...args].join(" "));

    // Spawn the Python process
    const python = spawn("python", args, { signal: controller.signal });
    setProcess(python); // üß† Store process so we can stop it later if needed

    let stdout = "";
    let stderr = "";

    // Listen for stdout logs from Python (normal output)
    python.stdout.on("data", (data) => {
      const msg = data.toString();
      stdout += msg;
      liveLogs.push(msg.trim());
    });

    // Listen for stderr logs from Python (warnings/errors)
    python.stderr.on("data", (data) => {
      const msg = data.toString();
      stderr += msg;
      liveLogs.push(`‚ö†Ô∏è ${msg.trim()}`);
    });

    // ‚è≥ Wait for Python process to finish
    const exitCode: number = await new Promise((resolve) => {
      python.on("close", resolve);
    });
    clearProcess(); // üßπ Clear active process reference after completion

    /**
     * ‚ùå Handle failure or user cancellation
     */
    if (exitCode !== 0) {
      const stoppedByUser = getWasStoppedByUser();
      await cleanupDir(candidatesDir);
      await cleanupDir(referenceDir);

      if (stoppedByUser) {
        return NextResponse.json(
          {
            canceled: true,
            logs: [...liveLogs.slice(-20), "üõë Process stopped by user"],
          },
          { status: 200 }
        );
      }

      return NextResponse.json(
        {
          error: "Python script failed.",
          details: stderr || stdout,
          logs: liveLogs.slice(-20),
        },
        { status: 500 }
      );
    }

    /**
     * üìù Read and parse Python JSON report
     */
    const reportPath = await findReportFile(outputDir);
    if (!reportPath) {
      console.error("‚ùå Report file not found in:", outputDir);
      return NextResponse.json(
        {
          error: "Python completed but no report file found.",
          logs: liveLogs.slice(-20),
        },
        { status: 500 }
      );
    }

    let reportData: any;
    try {
      const rawData = await fs.readFile(reportPath, "utf-8");
      reportData = JSON.parse(rawData);
    } catch (parseErr) {
      console.error("‚ùå Failed to parse report file:", parseErr);
      return NextResponse.json(
        {
          error: "Report file could not be parsed.",
          logs: liveLogs.slice(-20),
        },
        { status: 500 }
      );
    }

    // Ensure expected structure
    if (!reportData || !Array.isArray(reportData.items)) {
      console.error("‚ùå Report file missing expected 'items' array");
      return NextResponse.json(
        {
          error: "Report file is malformed or contains no results.",
          logs: liveLogs.slice(-20),
        },
        { status: 500 }
      );
    }

    if (reportData.items.length === 0) {
      console.warn("‚ö†Ô∏è Report contains 0 matched items.");
    }

    /**
     * üß≠ Build results list from report
     * - Includes aligned audio URL so frontend can play/download aligned files
     */
    const results = (reportData.items || []).map((item: any) => {
      let alignedUrl: string | null = null;
      const refFolder = reportData.base_dir; // name of folder where Python saved aligned files

      if (item.aligned_audio_rel) {
        // Build the final URL for the aligned audio file
        const fileName = path.basename(item.aligned_audio_rel);
        alignedUrl = `/api/aligned/${encodeURIComponent(refFolder)}/${encodeURIComponent(fileName)}`;
      } else {
        // Fallback guess if aligned_audio_rel is missing
        const guessedName = item.source_file.replace(/\.[^/.]+$/, "_aligned.wav");
        alignedUrl = `/api/aligned/${encodeURIComponent(refFolder)}/${encodeURIComponent(guessedName)}`;
      }

      return {
        filename: item.source_file,
        decision: item.decision,
        offset: item.final_offset_seconds ?? 0,
        confidence: item.confidence ?? 0,
        sanity_warning: item.sanity_warning === false ? null : item.sanity_warning,
        raw_offset: item.signed_offset_seconds ?? 0,
        tags: item.metadata?.tags || [],
        aligned_audio_rel: alignedUrl,
      };
    });

    console.log("‚úÖ Parsed results:", results.length);

    // üßπ Cleanup temp uploads
    await cleanupDir(candidatesDir);
    await cleanupDir(referenceDir);

    /**
     * ‚úÖ Return final structured response to frontend
     */
    return NextResponse.json({
      reference: path.basename(refPath),
      generatedAt: reportData.generated_at,
      total: results.length,
      results,
      logs: liveLogs.slice(-10),
    });

  } catch (err: any) {
    console.error("‚ùå Backend error:", err);
    return NextResponse.json(
      {
        error:
          err.name === "AbortError"
            ? "Process terminated due to timeout."
            : err.message || "Internal server error.",
      },
      { status: 500 }
    );
  }
}
